#ifndef OPTIONAL_SHIM_HPP
#define OPTIONAL_SHIM_HPP

// Optional shim: prefer <optional>, fallback to <experimental/optional>, otherwise provide minimal optional

#if defined(__has_include)
  #if __has_include(<optional>)
    #include <optional>
  #elif __has_include(<experimental/optional>)
    #include <experimental/optional>
    namespace std {
        using std::experimental::optional;
        using std::experimental::nullopt_t;
        using std::experimental::nullopt;
    }
  #else
    // Provide a minimal optional implementation (limited)
    #include <utility>
    #include <type_traits>
    #include <new>
    namespace std {
        struct nullopt_t { explicit constexpr nullopt_t(int) {} };
        inline constexpr nullopt_t nullopt{0};

        template <typename T>
        class optional {
            bool engaged_;
            typename std::aligned_storage<sizeof(T), alignof(T)>::type storage_;
        public:
            optional() noexcept : engaged_(false) {}
            optional(nullopt_t) noexcept : engaged_(false) {}
            optional(const T& val) : engaged_(true) { new (&storage_) T(val); }
            optional(T&& val) : engaged_(true) { new (&storage_) T(std::move(val)); }
            optional(const optional& other) : engaged_(other.engaged_) { if (engaged_) new (&storage_) T(*other); }
            optional(optional&& other) : engaged_(other.engaged_) { if (engaged_) new (&storage_) T(std::move(*other)); }
            ~optional() { reset(); }

            optional& operator=(nullopt_t) noexcept { reset(); return *this; }
            optional& operator=(const optional& other) { if (this != &other) { reset(); if (other.engaged_) new (&storage_) T(*other); engaged_ = other.engaged_; } return *this; }
            optional& operator=(optional&& other) { if (this != &other) { reset(); if (other.engaged_) new (&storage_) T(std::move(*other)); engaged_ = other.engaged_; } return *this; }

            explicit operator bool() const noexcept { return engaged_; }
            bool has_value() const noexcept { return engaged_; }
            T& operator*() { return *reinterpret_cast<T*>(&storage_); }
            const T& operator*() const { return *reinterpret_cast<const T*>(&storage_); }
            void reset() noexcept { if (engaged_) { reinterpret_cast<T*>(&storage_)->~T(); engaged_ = false; } }
        };
    }
  #endif
#else
  // No __has_include - assume experimental optional exists
  #include <experimental/optional>
  namespace std {
      using std::experimental::optional;
      using std::experimental::nullopt_t;
      using std::experimental::nullopt;
  }
#endif

#endif // OPTIONAL_SHIM_HPP
